name: æå–é›»è¦–å°åç¨±å’Œç”Ÿæˆåˆ†æå ±å‘Šï¼ˆå«åœ–è¡¨ï¼‰

on:
  schedule:
    - cron: '45 */6 * * *'
  workflow_dispatch:

jobs:
  extract:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install matplotlib pandas seaborn

      - name: Download XML files
        run: |
          curl -L --retry 3 --max-time 10 -o twepg.xml https://raw.githubusercontent.com/zzq1234567890/epg/main/twepg.xml
          curl -L --retry 3 --max-time 10 -o swepg.xml https://raw.githubusercontent.com/zzq1234567890/epg/main/swepg.xml
          [ -s twepg.xml ] || { echo "twepg.xml ä¸ºç©º"; exit 1; }
          [ -s swepg.xml ] || { echo "swepg.xml ä¸ºç©º"; exit 1; }

      - name: Extract channel names and generate JSON analysis
        run: |
          python <<'EOF'
          import xml.etree.ElementTree as ET
          import json
          from datetime import datetime
          import re

          def analyze_epg_data(xml_file):
              try:
                  tree = ET.parse(xml_file)
                  root = tree.getroot()
                  
                  ns = {}
                  if root.tag.startswith('{'):
                      ns_uri = root.tag.split('}')[0][1:]
                      ns = {'ns': ns_uri}
                  
                  channels_info = {}
                  channel_xpath = 'ns:channel' if ns else 'channel'
                  for channel in root.findall(channel_xpath, ns):
                      channel_id = channel.get('id')
                      if not channel_id:
                          continue
                      name = channel.get('display-name')
                      if not name:
                          name_elem = channel.find('ns:display-name' if ns else 'display-name', ns)
                          name = name_elem.text.strip() if name_elem is not None and name_elem.text else None
                      name = name.strip() if name else channel_id
                      
                      channels_info[channel_id] = {
                          'name': name,
                          'program_count': 0,
                          'start_times': [],
                          'end_times': []
                      }
                  
                  programme_xpath = 'ns:programme' if ns else 'programme'
                  for idx, programme in enumerate(root.findall(programme_xpath, ns)):
                      channel_id = programme.get('channel')
                      start_time = programme.get('start')
                      end_time = programme.get('stop')
                      
                      if channel_id not in channels_info:
                          continue
                      
                      channels_info[channel_id]['program_count'] += 1
                      
                      if start_time:
                          clean_start = re.sub(r'\s+[+-]\d{4}$', '', start_time)
                          channels_info[channel_id]['start_times'].append(clean_start)
                      if end_time:
                          clean_end = re.sub(r'\s+[+-]\d{4}$', '', end_time)
                          channels_info[channel_id]['end_times'].append(clean_end)
                  
                  result = []
                  for channel_id, info in channels_info.items():
                      time_range = "æš‚æ— èŠ‚ç›®æ•°æ®"
                      if info['start_times'] and info['end_times']:
                          try:
                              sorted_starts = sorted(info['start_times'])
                              sorted_ends = sorted(info['end_times'])
                              earliest_start = sorted_starts[0]
                              latest_end = sorted_ends[-1]
                              
                              start_dt = datetime.strptime(earliest_start, '%Y%m%d%H%M%S')
                              end_dt = datetime.strptime(latest_end, '%Y%m%d%H%M%S')
                              time_range = f"{start_dt.strftime('%Y-%m-%d %H:%M:%S')} è‡³ {end_dt.strftime('%Y-%m-%d %H:%M:%S')}"
                          except ValueError as e:
                              time_range = f"{earliest_start} è‡³ {latest_end}ï¼ˆæ ¼å¼å¼‚å¸¸ï¼‰"
                      
                      epg_status = "â– " if info['program_count'] > 0 else "â–¡"
                      
                      result.append({
                          'channel_id': channel_id,
                          'channel_name': info['name'],
                          'program_count': info['program_count'],
                          'time_range': time_range,
                          'epg_status': epg_status
                      })
                  
                  result.sort(key=lambda x: x['channel_name'].lower())
                  return result
                  
              except Exception as e:
                  print(f"âŒ è§£æ {xml_file} å‡ºé”™: {str(e)}")
                  return []

          print("å¼€å§‹åˆ†æ EPG æ•°æ®...")
          tw_data = analyze_epg_data('twepg.xml')
          sw_data = analyze_epg_data('swepg.xml')

          def generate_table(data, title):
              return {
                  'title': title,
                  'headers': ['é¢‘é“ID', 'é¢‘é“åç§°', 'èŠ‚ç›®æ•°é‡', 'æ—¶é—´èŒƒå›´', 'EPGçŠ¶æ€'],
                  'data': [[
                      ch['channel_id'],
                      ch['channel_name'],
                      ch['program_count'],
                      ch['time_range'],
                      ch['epg_status']
                  ] for ch in data]
              }

          tw_table = generate_table(tw_data, 'ç¹ä½“ç”µè§†é¢‘é“åˆ—è¡¨')
          sw_table = generate_table(sw_data, 'ç®€ä½“ç”µè§†é¢‘é“åˆ—è¡¨')

          def generate_detailed(data, table, lang):
              return {
                  'table_format': table,
                  'channels': data,
                  'summary': {
                      'total_channels': len(data),
                      'total_programs': sum(ch['program_count'] for ch in data),
                      'channels_with_epg': len([ch for ch in data if ch['epg_status'] == 'â– ']),
                      'channels_without_epg': len([ch for ch in data if ch['epg_status'] == 'â–¡']),
                      'date_generated': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  }
              }

          tw_detailed = generate_detailed(tw_data, tw_table, 'ç¹ä½“')
          sw_detailed = generate_detailed(sw_data, sw_table, 'ç®€ä½“')

          output_files = [
              ('traditional_channels_table.json', tw_table),
              ('simplified_channels_table.json', sw_table),
              ('traditional_channels_detailed.json', tw_detailed),
              ('simplified_channels_detailed.json', sw_detailed)
          ]

          for filename, content in output_files:
              with open(filename, 'w', encoding='utf-8') as f:
                  json.dump(content, f, ensure_ascii=False, indent=2)

          print(f"âœ… ç¹é«”é›»è¦–å°: å…±åˆ†æ {len(tw_data)} ä¸ªé¢‘é“")
          print(f"âœ… ç®€ä½“ç”µè§†å°: å…±åˆ†æ {len(sw_data)} ä¸ªé¢‘é“")
          print(f"âœ… ç¹é«”ç¯€ç›®ç¸½æ•¸: {sum(ch['program_count'] for ch in tw_data)}")
          print(f"âœ… ç®€ä½“ç¯€ç›®ç¸½æ•¸: {sum(ch['program_count'] for ch in sw_data)}")
          print("ğŸ“ å·²ç”Ÿæˆæ–‡ä»¶:")
          for filename, _ in output_files:
              print(f"   - {filename}")
          EOF

      - name: Generate charts and images
        run: |
          python <<'EOF'
          import matplotlib.pyplot as plt
          import matplotlib.font_manager as fm
          import pandas as pd
          import json
          import os
          from datetime import datetime

          # è®¾ç½®ä¸­æ–‡å­—ä½“
          try:
              plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'SimHei', 'Arial Unicode MS']
              plt.rcParams['axes.unicode_minus'] = False
          except:
              print("ä½¿ç”¨é»˜è®¤å­—ä½“")

          def load_data():
              with open('traditional_channels_detailed.json', 'r', encoding='utf-8') as f:
                  tw_data = json.load(f)
              with open('simplified_channels_detailed.json', 'r', encoding='utf-8') as f:
                  sw_data = json.load(f)
              return tw_data, sw_data

          def create_summary_chart(tw_data, sw_data):
              fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
              
              # é¢‘é“æ•°é‡å¯¹æ¯”
              labels = ['ç¹ä½“é¢‘é“', 'ç®€ä½“é¢‘é“']
              total_channels = [tw_data['summary']['total_channels'], sw_data['summary']['total_channels']]
              channels_with_epg = [tw_data['summary']['channels_with_epg'], sw_data['summary']['channels_with_epg']]
              
              x = range(len(labels))
              width = 0.35
              
              ax1.bar(x, total_channels, width, label='æ€»é¢‘é“æ•°', alpha=0.8)
              ax1.bar([i + width for i in x], channels_with_epg, width, label='æœ‰EPGé¢‘é“æ•°', alpha=0.8)
              ax1.set_xlabel('é¢‘é“ç±»å‹')
              ax1.set_ylabel('æ•°é‡')
              ax1.set_title('é¢‘é“æ•°é‡ç»Ÿè®¡')
              ax1.set_xticks([i + width/2 for i in x])
              ax1.set_xticklabels(labels)
              ax1.legend()
              ax1.grid(True, alpha=0.3)
              
              # èŠ‚ç›®æ•°é‡å¯¹æ¯”
              total_programs = [tw_data['summary']['total_programs'], sw_data['summary']['total_programs']]
              bars = ax2.bar(labels, total_programs, color=['#ff9999', '#66b3ff'], alpha=0.8)
              ax2.set_ylabel('èŠ‚ç›®æ•°é‡')
              ax2.set_title('æ€»èŠ‚ç›®æ•°é‡å¯¹æ¯”')
              ax2.grid(True, alpha=0.3)
              
              # åœ¨æŸ±çŠ¶å›¾ä¸Šæ˜¾ç¤ºæ•°å€¼
              for bar in bars:
                  height = bar.get_height()
                  ax2.text(bar.get_x() + bar.get_width()/2., height + 100,
                          f'{height:,}', ha='center', va='bottom')
              
              # EPGè¦†ç›–ç‡
              tw_coverage = tw_data['summary']['channels_with_epg'] / tw_data['summary']['total_channels'] * 100
              sw_coverage = sw_data['summary']['channels_with_epg'] / sw_data['summary']['total_channels'] * 100
              
              coverage_data = [tw_coverage, sw_coverage]
              bars = ax3.bar(labels, coverage_data, color=['#99ff99', '#ffcc99'], alpha=0.8)
              ax3.set_ylabel('è¦†ç›–ç‡ (%)')
              ax3.set_title('EPGè¦†ç›–ç‡')
              ax3.set_ylim(0, 100)
              ax3.grid(True, alpha=0.3)
              
              for bar in bars:
                  height = bar.get_height()
                  ax3.text(bar.get_x() + bar.get_width()/2., height + 1,
                          f'{height:.1f}%', ha='center', va='bottom')
              
              # æ— EPGé¢‘é“æ•°é‡
              no_epg_data = [
                  tw_data['summary']['channels_without_epg'],
                  sw_data['summary']['channels_without_epg']
              ]
              ax4.pie(no_epg_data, labels=labels, autopct='%1.1f%%', startangle=90, colors=['#ff9999', '#66b3ff'])
              ax4.set_title('æ— EPGé¢‘é“åˆ†å¸ƒ')
              
              plt.tight_layout()
              plt.savefig('epg_summary_charts.png', dpi=150, bbox_inches='tight')
              plt.close()
              print("âœ… å·²ç”Ÿæˆæ±‡æ€»å›¾è¡¨: epg_summary_charts.png")

          def create_program_distribution_chart(tw_data, sw_data):
              # èŠ‚ç›®æ•°é‡åˆ†å¸ƒåˆ†æ
              tw_programs = [ch['program_count'] for ch in tw_data['channels'] if ch['program_count'] > 0]
              sw_programs = [ch['program_count'] for ch in sw_data['channels'] if ch['program_count'] > 0]
              
              fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
              
              # ç¹ä½“é¢‘é“èŠ‚ç›®æ•°é‡åˆ†å¸ƒ
              ax1.hist(tw_programs, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
              ax1.set_xlabel('èŠ‚ç›®æ•°é‡')
              ax1.set_ylabel('é¢‘é“æ•°é‡')
              ax1.set_title('ç¹ä½“é¢‘é“èŠ‚ç›®æ•°é‡åˆ†å¸ƒ')
              ax1.grid(True, alpha=0.3)
              
              # ç®€ä½“é¢‘é“èŠ‚ç›®æ•°é‡åˆ†å¸ƒ
              ax2.hist(sw_programs, bins=30, alpha=0.7, color='lightcoral', edgecolor='black')
              ax2.set_xlabel('èŠ‚ç›®æ•°é‡')
              ax2.set_ylabel('é¢‘é“æ•°é‡')
              ax2.set_title('ç®€ä½“é¢‘é“èŠ‚ç›®æ•°é‡åˆ†å¸ƒ')
              ax2.grid(True, alpha=0.3)
              
              plt.tight_layout()
              plt.savefig('program_distribution.png', dpi=150, bbox_inches='tight')
              plt.close()
              print("âœ… å·²ç”ŸæˆèŠ‚ç›®åˆ†å¸ƒå›¾è¡¨: program_distribution.png")

          def create_status_chart(tw_data, sw_data):
              # EPGçŠ¶æ€ç»Ÿè®¡
              fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
              
              # ç¹ä½“é¢‘é“EPGçŠ¶æ€
              tw_epg_status = [tw_data['summary']['channels_with_epg'], tw_data['summary']['channels_without_epg']]
              ax1.pie(tw_epg_status, labels=['æœ‰EPG', 'æ— EPG'], autopct='%1.1f%%', startangle=90, colors=['#66c2a5', '#fc8d62'])
              ax1.set_title('ç¹ä½“é¢‘é“EPGçŠ¶æ€')
              
              # ç®€ä½“é¢‘é“EPGçŠ¶æ€
              sw_epg_status = [sw_data['summary']['channels_with_epg'], sw_data['summary']['channels_without_epg']]
              ax2.pie(sw_epg_status, labels=['æœ‰EPG', 'æ— EPG'], autopct='%1.1f%%', startangle=90, colors=['#8da0cb', '#e78ac3'])
              ax2.set_title('ç®€ä½“é¢‘é“EPGçŠ¶æ€')
              
              plt.tight_layout()
              plt.savefig('epg_status_charts.png', dpi=150, bbox_inches='tight')
              plt.close()
              print("âœ… å·²ç”ŸæˆEPGçŠ¶æ€å›¾è¡¨: epg_status_charts.png")

          # ç”Ÿæˆæ‰€æœ‰å›¾è¡¨
          tw_data, sw_data = load_data()
          create_summary_chart(tw_data, sw_data)
          create_program_distribution_chart(tw_data, sw_data)
          create_status_chart(tw_data, sw_data)
          
          # ç”Ÿæˆæ›´æ–°æ—¶é—´æ–‡ä»¶
          update_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
          with open('last_update.txt', 'w', encoding='utf-8') as f:
              f.write(f"æœ€åæ›´æ–°æ—¶é—´: {update_time}")
          print("âœ… å·²ç”Ÿæˆæ›´æ–°æ—¶é—´æ–‡ä»¶")
          EOF

      - name: Extract channel names (ä¿æŒé¡ºåº)
        run: |
          python <<'EOF'
          import xml.etree.ElementTree as ET
          import re

          def extract_names(xml_file, output_file):
              try:
                  tree = ET.parse(xml_file)
                  root = tree.getroot()
                  ns = {}
                  if root.tag.startswith('{'):
                      ns_uri = root.tag.split('}')[0][1:]
                      ns = {'ns': ns_uri}
                  
                  seen = set()
                  channels = []
                  channel_xpath = 'ns:channel' if ns else 'channel'
                  for c in root.findall(channel_xpath, ns):
                      name = c.get('display-name')
                      if not name:
                          name_elem = c.find('ns:display-name' if ns else 'display-name', ns)
                          name = name_elem.text.strip() if name_elem is not None and name_elem.text else None
                      name = name.strip() if name else c.get('id', '')
                      if name and name not in seen:
                          seen.add(name)
                          channels.append(name)

                  with open(output_file, 'w', encoding='utf-8') as f:
                      f.write('\n'.join(channels))
                  print(f"âœ… {xml_file}: å…±æå– {len(channels)} ä¸ªé¢‘é“ï¼Œå·²ä¿å­˜åˆ° {output_file}")
              except Exception as e:
                  print(f"âŒ è§£æ {xml_file} å‡ºé”™: {str(e)}")

          extract_names('twepg.xml', 'ç¹é«”é›»è¦–å°ç›®éŒ„.txt')
          extract_names('swepg.xml', 'ç®€ä½“ç”µè§†å°ç›®å½•.txt')
          EOF

      - name: Generate README with images
        run: |
          python <<'EOF'
          from datetime import datetime
          
          update_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
          
          readme_content = f"""# EPG æ•°æ®ç›‘æ§ä¸åˆ†æ

æœ€åæ›´æ–°æ—¶é—´: {update_time}

## ğŸ“Š æ•°æ®æ¦‚è§ˆ

![æ•°æ®æ±‡æ€»å›¾è¡¨](./epg_summary_charts.png)

## ğŸ“ˆ è¯¦ç»†åˆ†æ

### èŠ‚ç›®æ•°é‡åˆ†å¸ƒ
![èŠ‚ç›®åˆ†å¸ƒå›¾è¡¨](./program_distribution.png)

### EPGçŠ¶æ€ç»Ÿè®¡
![EPGçŠ¶æ€å›¾è¡¨](./epg_status_charts.png)

## ğŸ“º é¢‘é“åˆ—è¡¨

- [ç¹ä½“ç”µè§†é¢‘é“åˆ—è¡¨](ç¹é«”é›»è¦–å°ç›®éŒ„.txt)
- [ç®€ä½“ç”µè§†å°ç›®å½•](ç®€ä½“ç”µè§†å°ç›®å½•.txt)

## ğŸ“‹ æ•°æ®æ–‡ä»¶

- [ç¹ä½“é¢‘é“è¯¦ç»†æ•°æ®](traditional_channels_detailed.json)
- [ç®€ä½“é¢‘é“è¯¦ç»†æ•°æ®](simplified_channels_detailed.json)
- [ç¹ä½“é¢‘é“è¡¨æ ¼æ•°æ®](traditional_channels_table.json)
- [ç®€ä½“é¢‘é“è¡¨æ ¼æ•°æ®](simplified_channels_table.json)

## ğŸ”„ è‡ªåŠ¨æ›´æ–°

æœ¬ä»“åº“æ¯6å°æ—¶è‡ªåŠ¨æ›´æ–°ä¸€æ¬¡EPGæ•°æ®å¹¶ç”Ÿæˆåˆ†ææŠ¥å‘Šã€‚
"""

          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(readme_content)
          
          print("âœ… å·²æ›´æ–° README.md")
          EOF

      - name: Commit and push results
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # æäº¤æ‰€æœ‰ç”Ÿæˆçš„æ–‡ä»¶ï¼ŒåŒ…æ‹¬å›¾ç‰‡
          git add "ç¹é«”é›»è¦–å°ç›®éŒ„.txt" "ç®€ä½“ç”µè§†å°ç›®å½•.txt" "*.json" "*.png" "last_update.txt" "README.md"
          
          if git diff --cached --quiet; then
            echo "âš ï¸ æ²¡æœ‰éœ€è¦æäº¤çš„å˜æ›´"
          else
            git commit -m "Update EPG analysis with charts and images (auto-generated)"
            for i in {1..3}; do
              if git push; then
                echo "âœ… æäº¤å¹¶æ¨é€æˆåŠŸ"
                exit 0
              else
                echo "âš ï¸ æ¨é€å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•ï¼ˆç¬¬ $i æ¬¡ï¼‰"
                git pull --rebase
              fi
            done
            echo "âŒ å¤šæ¬¡æ¨é€å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤„ç†"
            exit 1
          fi
